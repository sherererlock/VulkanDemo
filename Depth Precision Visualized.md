**Depth Precision Visualized**


深度精度是每个图形程序员迟早都必须努力解决的问题。关于这个主题已经有许多文章和论文，不同的游戏、引擎和设备使用了各种不同的深度缓冲区格式和设置。

由于它与透视投影的相互作用方式，GPU 硬件深度映射有点晦涩，研究方程可能不会立即让事情变得明显。为了对其工作原理有所了解，绘制一些图示是有帮助的。

这篇文章分为三个主要部分。第一部分，我尝试提供一些非线性深度映射的动机。第二部分，我提供一些图表，以帮助理解在不同情况下非线性深度映射是如何直观和视觉地工作的。第三部分是关于保罗·阿普彻和马修·德斯布伦（2012）的《紧缩透视渲染精度》一文的讨论和复现，涉及浮点舍入误差对深度精度的影响。

**Why 1/z**

GPU硬件深度缓冲区通常不会存储物体距相机前方的距离的线性表示，这与人们初次遇到时可能天真地期望的情况相反。相反，深度缓冲区存储的是与世界空间深度的倒数成比例的值。我想简要解释一下这种约定的动机。

在这篇文章中，我将用d来表示深度缓冲区中存储的值（在[0, 1]范围内），用z来表示世界空间深度，即沿着视轴的距离，以米等世界单位表示。一般来说，它们之间的关系可以表示为：

![Why 1/z](https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/math1.jpg)


其中a和b是与近平面和远平面设置相关的常数。换句话说，d始终是1/z的某种线性重新映射。 从表面上看，你可以想象将d视为任何你喜欢的z的函数。那么为什么选择这个特定的方式呢？这有两个主要原因。

首先，1/z自然适应了透视投影的框架。这是保证保持直线的最一般的转换类别，这使得它对于硬件光栅化非常方便，因为三角形的直边在屏幕空间中保持直线。我们可以通过利用硬件已经执行的透视除法来生成1/z的线性重新映射

![Why 1/z](https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/math2.jpg)

当然，这种方法的真正优势在于投影矩阵可以与其他矩阵相乘，从而允许您将许多转换阶段组合在一起。 第二个原因是，正如 Emil Persson 指出的那样，1/z 在屏幕空间中是线性的。因此，在光栅化过程中在三角形上插值d很容易，而诸如分层Z缓冲、提前Z剔除和深度缓冲区压缩等都变得更加容易实现。

**Graphing Depth Maps**

![Graphing Depth Maps](https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph1.jpg)


这些图表的阅读方式是从左到右，然后下移到底部。从左轴开始，首先观察d的图表。由于d可以是1/z的任意线性重新映射，我们可以在此轴上任意放置0和1。刻度标记表示不同的深度缓冲值。为了说明，我模拟了一个4位规范化整数深度缓冲区，因此有16个均匀间隔的刻度标记。

水平追踪刻度标记，直到它们与1/z曲线相交，然后沿着底轴向下。这是不同的值在世界空间深度范围内的位置。

上面的图表显示了D3D和类似API中使用的“标准”深度映射。您可以立即看到1/z曲线如何导致将值聚集在靠近近平面的位置，而靠近远平面的值则相当分散。

同时，您也很容易看出为什么近平面对深度精度有如此深远的影响。拉近近平面会使d范围迅速上升，接近1/z曲线的渐近线，导致值的分布更加不均衡：

![Graphing Depth Maps](https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph2.jpg)

同样，在这种情况下很容易看出，将远平面推到无穷远并没有太大的影响。这只是意味着稍微将d范围延伸到1/z=0：

![Graphing Depth Maps](https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph3.jpg)

关于浮点深度呢？下面的图表添加了与模拟的浮点格式相对应的刻度标记，其中有3个指数位和3个尾数位：

![Graphing Depth Maps](https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph4.jpg)


现在在 [0, 1] 范围内有 40 个不同的值——比之前的 16 个值要多得多，但其中大多数都被无用地聚集在了我们实际上不需要更高精度的近平面附近。

一个现在广为人知的技巧是反转深度范围，将近平面映射到 d=1，将远平面映射到 d=0：

![Graphing Depth Maps](https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph5.jpg)


好多了！现在浮点数的准对数分布在一定程度上抵消了1/z的非线性，使得我们在近平面附近的精度类似于整数深度缓冲区，在其他地方的精度大大提高。随着您移动到更远的地方，精度仅缓慢恶化。

反向-Z技巧可能已经被独立发明了多次，但至少可以追溯到Eugene Lapidous和Guofang Jiao在SIGGRAPH '99的一篇论文中（很遗憾，没有开放访问链接）。最近，Matt Pettineo和Brano Kemen的博客文章以及Emil Persson的Creating Vast Game Worlds SIGGRAPH 2012演讲重新使其受到关注。

之前的所有图表都假设[0, 1]是投影后的深度范围，这是D3D的惯例。那么OpenGL呢？

![Graphing Depth Maps](https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph6.jpg)


OpenGL 默认假设投影后的深度范围为 [-1, 1]。对于整数格式，这没有什么区别，但对于浮点数，所有的精度都无用地集中在中间。（这个值稍后会被映射到 [0, 1] 以在深度缓冲区中存储，但这没有帮助，因为初始映射到 [-1, 1] 已经在范围的远半部分破坏了所有的精度。）由于对称性，反向-Z技巧在这里不起作用。

幸运的是，在桌面版的 OpenGL 中，您可以通过被广泛支持的 ARB_clip_control 扩展（现在也作为 glClipControl 核心部分包含在 OpenGL 4.5 中）来解决这个问题。不幸的是，在 GL ES 中您就没有这个机会了。

**The Effects of Roundoff Error**


1/z 映射和选择浮点数与整数深度缓冲区是精度问题的一部分，但并不是全部。即使您有足够的深度精度来表示您要渲染的场景，您可能最终会发现您的精度受到顶点转换过程中算术误差的控制。

如前所述，Upchurch 和 Desbrun 通过一种分析技术得出了两个主要建议，以最小化舍入误差：

1. 使用无限远平面。
2. 将投影矩阵与其他矩阵分开，并在顶点着色器中单独应用它，而不是将其组合到视图矩阵中。

Upchurch 和 Desbrun 通过一种分析技术提出了这些建议，该技术是基于将舍入误差视为在每个算术操作中引入的小随机扰动，并通过转换过程中的一阶跟踪它们。我决定使用直接模拟来检查结果。

我的源代码在这里——使用 Python 3.4 和 numpy。它通过生成一个随机点序列，按深度排序，在近平面和远平面之间以线性或对数间隔分布。然后，它通过视图矩阵和投影矩阵以及透视除法传递点，始终使用32位浮点精度，最后可以将最终结果量化为24位整数。最后，它在序列中运行，并计算相邻两个点（最初具有不同深度）变得无法区分的次数，因为它们映射到相同的深度值，或者实际上交换了顺序。换句话说，它衡量了在不同情况下发生深度比较错误的速率，这对应于类似于 Z-fighting 的问题。

以下是在近 = 0.1，远 = 10K 的情况下获得的结果，使用了10K个线性间隔的深度。（我还尝试过对数深度间隔和其他近/远比率，虽然详细数据有所不同，但结果的一般趋势是相同的。）

在表格中，“indist”表示不可区分（两个相邻的深度映射到相同的最终深度缓冲区值），而“swap”表示两个相邻的深度交换了顺序。

| Precomposed view- projection matrix | Separate view and projection matrices |                     |                    |                    |
| :---------------------------------- | :-----------------------------------: | :-----------------: | :----------------: | :----------------: |
|                                     |                float32                |        int24        |      float32       |       int24        |
| Unaltered Z values (control test)   |           0% indist 0% swap           |  0% indist 0% swap  | 0% indist 0% swap  | 0% indist 0% swap  |
| Standard projection                 |          45% indist 18% swap          | 45% indist 18% swap | 77% indist 0% swap | 77% indist 0% swap |
| Infinite far plane                  |          45% indist 18% swap          | 45% indist 18% swap | 76% indist 0% swap | 76% indist 0% swap |
| Reversed Z                          |           0% indist 0% swap           | 76% indist 0% swap  | 0% indist 0% swap  | 76% indist 0% swap |
| Infinite + reversed-Z               |           0% indist 0% swap           | 76% indist 0% swap  | 0% indist 0% swap  | 76% indist 0% swap |
| GL-style standard                   |          56% indist 12% swap          | 56% indist 12% swap | 77% indist 0% swap | 77% indist 0% swap |
| GL-style infinite                   |          59% indist 10% swap          | 59% indist 10% swap | 77% indist 0% swap | 77% indist 0% swap |

非常抱歉，我未能为这些内容绘制图表，因为其中涉及的维度太多，不易于绘制！无论如何，从数据上看，有一些普遍的结果是清晰的。

在大多数情况下，浮点数和整数深度缓冲区之间没有区别。算术误差压倒了量化误差。部分原因是因为 float32 和 int24 在 [0.5, 1] 范围内几乎有相同大小的 ulp（因为 float32 有 23 位尾数），因此在绝大多数深度范围内实际上几乎没有额外的量化误差。 在许多情况下，将视图和投影矩阵分开（遵循 Upchurch 和 Desbrun 的建议）确实会有所改进。尽管它并不会降低整体误差率，但似乎会将交换转变为不可区分，这是朝着正确方向迈出的一步。 无限远平面对错误率的影响仅微不足道。Upchurch 和 Desbrun 预测了绝对数值误差的减少25％，但似乎并未转化为降低的比较错误率。 然而，上述观点在实际上基本无关紧要，因为在这里真正重要的结果是：反向-Z映射基本上是神奇的。看看这个：

使用浮点深度缓冲区的反向-Z在这个测试中产生了零错误率。当然，如果您不断缩小输入深度值的间距，仍然可以生成一些错误。然而，反向-Z与浮点数一起，比任何其他选项都要准确得多。 使用整数深度缓冲区的反向-Z与其他整数选项一样好。 反向-Z消除了预合成视图/投影矩阵与分开的视图/投影矩阵以及有限/无限远平面之间的区别。换句话说，使用反向-Z，您可以将投影矩阵与其他矩阵组合，并且可以使用任何您喜欢的远平面，而不会影响精度。 我认为结论很明确。在任何透视投影情况下，只需使用带有反向-Z的浮点深度缓冲区！如果无法使用浮点深度缓冲区，您仍然应该使用反向-Z。尤其是如果您正在构建包含极端深度范围的开放世界环境，它并不是解决所有精度问题的万能药。但这是一个很好的开始。

**A couple of notes about Z**


通常说 Z 值是非线性的，而 W 值是线性的。这使得 W 缓冲区在视图锥体内具有均匀分布的分辨率，而 Z 缓冲区在近距离具有更好的精度，但在远处精度较差。考虑到物体通常不会因为距离而变厚，相对于 Z 缓冲区，W 缓冲区在相同位数下通常具有较少的伪影。在过去，一些硬件支持了 W 缓冲区，但现在它们被视为废弃，硬件不再实现它。为什么呢，它们不更好吗？实际上并不是这样。原因如下：

尽管 W 在视图空间中是线性的，但在屏幕空间中并不是线性的。另一方面，非线性的 Z 在屏幕空间中是线性的。这一事实可以通过在 DX10 中的简单着色器观察到：

```

float dx = ddx(In.position.z);
float dy = ddy(In.position.z);
return 1000.0 * float4(abs(dx), abs(dy), 0, 0);
```

这里的 In.position 是 SV_Position。结果看起来类似于这样：

![img](http://www.humus.name/News/ZGradient.png)


注意所有表面都呈单一颜色。在给定的任何基元中，Z 像素到像素之间的差异是相同的。这对硬件非常重要。其中一个原因是，插值 Z 的成本要低于插值 W。Z 不需要透视校正。通过硬件中的更便宜的单元，您可以在相同的晶体管预算下每个周期拒绝更多的像素。当然，这在预 Z 通道和阴影图上非常重要。对于现代硬件而言，屏幕空间中的线性性质也被证明是 Z 优化的一个非常有用的属性。鉴于在基元中梯度是恒定的，计算在 Hi-Z 剔除中一个瓦片内的精确深度范围也相对容易。这也意味着诸如 Z 压缩之类的技术是可行的。由于 X 和 Y 中的 Z 值恒定，您不需要存储大量信息即可完全恢复瓦片内的所有 Z 值，前提是基元覆盖了整个瓦片。

现在，深度缓冲区越来越多地被用于除了隐藏表面去除之外的其他目的。在屏幕空间中是线性的事实证明是一种非常理想的属性，适用于后期处理。例如，假设您想要对深度缓冲区进行边缘检测，可能是为了通过模糊边缘进行抗锯齿处理。这可以通过比较像素的深度与其邻居的深度来轻松实现。对于 Z 值，除了边缘，像素到像素的 delta 是恒定的。通过将 delta 与左侧和右侧进行比较，如果它们不匹配（带有一些 epsilon），则表示穿过了边缘。当然，上下和对角线也是一样的。通过这种方式，如果您实现了模糊滤镜，但不希望在边缘处模糊，您还可以拒绝不属于同一表面的像素，例如用于平滑屏幕空间效果中的伪影，例如对相对稀疏采样的 SSAO 进行平滑处理。

那么，在进行隐藏表面去除时，视图空间的精度如何呢？与 W 缓冲相比，通过切换到浮点深度缓冲区，您可以恢复大部分丢失的精度。这样，您将获得两种类型的非线性，它们在很大程度上互相抵消，即来自 Z 和浮点表示的非线性。为了使此方法有效，您必须翻转深度缓冲区，使远平面为 0.0，近平面为 1.0，这是即使在使用固定点缓冲区时也建议的做法，因为它还可以提高变换过程中的数学精度。您还必须将深度测试从 LESS 切换到 GREATER。如果您依赖于库函数来计算投影矩阵，例如 D3DXMatrixPerspectiveFovLH()，实现这一点最简单的方法就是交换近平面和远平面参数。