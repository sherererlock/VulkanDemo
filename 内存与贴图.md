# Vulkan内存与贴图

Vulkan将内存划分为两大类：**Host Memory** 和 **Device Memory**。Host是运行应用程序的处理器，在PC机上就是指CPU。Device是执行Vulkan命令的处理器，在PC机上就是指GPU。

Vulkan系统中的内存有四种类型

- Host Local Memory，只对Host可见的内存，通常称之为普通内存
- Device Local Memory，只对Device可见的内存，通常称之为显存
- Host Local Device Memory，由Host管理的，对Device看见的内存
- Device Local Host Memory，由Device管理的，对Host可见的内存

一般在管线中用到的内存，都会从Host转换成Device。

## Vulkan缓冲

#### VkBufferCreateInfo

- flags 用于配置缓冲的内存稀疏程度
- usage buffer的数据的使用目的。常用的有vertexbuffer,uniformbuffer以及用来拷贝的源和目的地
- size buffer所占用的内存大小
- sharingMode 是被一个队列族独占还是被多个队列族共享

#### vkCreateBuffer, VkBuffer

#### VkMemoryRequirements 

- size 缓冲需要的内存的字节大小

- alignment 缓冲在实际被分配的内存中的开始位置。它的值依赖于bufferInfo.usage和bufferInfo.flags

- memoryTypeBIts 指示适合该缓冲使用的内存类型的位域

  GPU分配不同类型的内存作为缓冲使用。不同类型的内存所允许进行的操作以及操作的效率有所不同

#### vkGetBufferMemoryRequirements

#### VkMemoryPropertyFlags

内存的类型，从上面那四大类中分为更细的类型，根据memoryTypeBIt 来选择

- VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT 
- VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT 
- VK_MEMORY_PROPERTY_HOST_COHERENT_BIT 

#### VkMemoryAllocateInfo

- allocationSize VkMemoryRequirements 的size，表示实际分配的内存大小
- memoryTypeIndex 需要创建的mem type在物理设备支持的内存类型数组中的索引

#### vkAllocateMemory,VkDeviceMemory 

#### vkBindBufferMemory

#### 创建一个缓冲的一般步骤：

1. 创建缓冲
2. 确定缓冲所需要的内存类型，选择合适的类型可以提高性能
3. 创建缓冲所需的内存
4. 绑定缓冲和内存

### 顶点缓冲

```c
VkBufferCreateInfo bufferInfo = {};
bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
bufferInfo.size = sizeof(vertices[0]) * vertices.size();
bufferInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

VkMemoryAllocateInfo allocInfo = {};
allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
allocInfo.allocationSize = memRequirements.size;
//cpu可写以及缓存一致性
allocInfo.memoryTypeIndex = findMemoryTyp(memRequirements.memoryTypeBits, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);

void* data;
vkMapMemory(device, vertexBufferMemory, 0, bufferInfo.size, 0, &data);
memcpy(data, vertices.data(), (size_t) bufferInfo.size);
vkUnmapMemory(device, vertexBufferMemory);

vkCmdBindVertexBuffers(commandBuffers[i], 0, 1, vertexBuffers, offsets);
```

#### 暂存缓冲

最适合显卡读取的内存类型具有VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT标记，含有这一标记的内存类型通常CPU无法直接访问。一般会创建两个顶点缓冲。一个用于CPU加载数据，一个用于显卡设备读取数据。我们通过缓冲复制指令将CPU加载到的缓冲中的数据复制到显卡可以快速读取的缓冲中去

复制数据需要使用命令队列，队列族需要支持VK_QUEUE_TRANSFER_BIT特性，对于支持VK_QUEUE_GRAPHICS_BIT或VK_QUEUE_COMPUTE_BIT特性的队列族，VK_QUEUE_TRANSFER_BIT特性一定被支持，所以我们不需要显式地检测队列族是否支持VK_QUEUE_TRANSFER_BIT特性

#### 暂存缓冲

usage是`VK_BUFFER_USAGE_TRANSFER_SRC_BIT`

memory type是`VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT`

#### vertexBuffer

usage是`VK_BUFFER_USAGE_TRANSFER_DST_BIT|VK_BUFFER_USAGE_VERTEX_BUFFER_BIT`

memory type是`VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`

```
VkBuffer stagingBuffer;
VkDeviceMemory stagingBufferMemory;
createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);

void* data;
vkMapMemory(device, stagingBufferMemory, 0, bufferSize, 0, &data);
memcpy(data, vertices.data(), (size_t) bufferSize);
vkUnmapMemory(device, stagingBufferMemory);

createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, vertexBuffer,
vertexBufferMemory);
```

拷贝buffer的指令减CommandBuffer篇

### Uniform Buffer

usage是`VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT`

memtype是 `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT`

#### VkDescriptorBufferInfo

## 贴图

#### VkImageCreateInfo 

- imageType 一般为`VK_IMAGE_TYPE_2D`

- format

- mipLevels 

- arrayLayers cubemap一般为6，其他为1

- samples 除了用于msaa的都为`VK_SAMPLE_COUNT_1_BIT`

- tiling 

  - `VK_IMAGE_TILING_OPTIMAL`纹素以一种对访问优化的方式排列，在空间上相邻的像素在内存里也尽可能相邻
  - `VK_IMAGE_TILING_LINEAR` 纹素以行主序的方式排列

- initialLayout

- usage 

  对于贴图：`VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT`

  对于RT: `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`

#### vkCreateImage, VkImage

贴图资源需要手动为其分配内存，也用VkDeviceMemory对象，过程与缓冲对象别无二致。

贴图资源从硬盘加载到内存然后传输到显存，也需要拷贝，流程与顶点缓冲一样。

```c
vkCreateImage(device->logicalDevice, &imageCreateInfo, nullptr, &mappableImage);
vkGetImageMemoryRequirements(device->logicalDevice, mappableImage, &memReqs);
vkAllocateMemory(device->logicalDevice, &memAllocInfo, nullptr, &mappableMemory);
vkBindImageMemory(device->logicalDevice, mappableImage, mappableMemory, 0);    
```

#### 布局变换

与内存不同的是，Image对象需要布局变换

#### VkImageMemoryBarrier 

##### VkImageSubresourceRange

布局变换中受影响的图像范围

布局变换需要命令来执行，所以需要同步。

- oldLayout，newLayout 布局变换前后的layout

  如果不需要访问之前的图像数据，可以将oldLayout设置为VK_IMAGE_LAYOUT_UNDEFINED来获得更好的性能表现

- srcQueueFamilyIndex，dstQueueFamilyIndex

  用屏障来传递队列族所有权

- srcAccessMask，dstAccessMask

  屏障之前必须发生的资源操作类型，以及必须等待屏障的资源操作类型

- subresourceRange

#### 复制图像数据

#### VkBufferImageCopy

从buffer中拷贝到Image时使用的数据结构

