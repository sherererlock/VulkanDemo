# Hierarchical-Z map based occlusion culling

这篇文章介绍了分层Z缓冲（Hierarchical-Z），它是现代GPU中一种广为人知且标准的功能，通过在芯片内存中使用简化和压缩的深度缓冲，加快深度测试以拒绝大量的片段。本文提出的技术使用相同的基本思想，通过几何着色器实现批处理遮挡剔除，用于大量个体对象的遮挡剔除，而无需使用传统的遮挡查询需要的CPU干预。文章还通过OpenGL 4.0的山脉演示提供了一个参考实现，用于对成千上万个对象实例进行剔除处理。


Occlusion culling是一种用于确定可见性的算法，用于识别那些位于视图体积内但由于遮挡而在屏幕上不可见的对象。这意味着它们被位于相机更近位置的其他对象遮挡了。

多代GPU现在都支持硬件加速的遮挡剔除方法，以遮挡查询（occlusion queries）的形式实现。OpenGL通过扩展ARB_occlusion_query提供了这种功能。遮挡查询非常简单：当你启用了遮挡查询并绘制一个对象时，查询将返回通过深度测试的样本数量（或者根据对象的样本是否通过深度测试返回true或false，这是由OpenGL扩展ARB_occlusion_query2提供的功能）。


实际上，使用遮挡查询（Occlusion Queries）执行遮挡剔除的步骤如下：

1. 启用遮挡查询：在绘制对象之前，需要启用遮挡查询。通常，这是通过图形编程中的API调用（如OpenGL或DirectX）来实现的。
2. 绘制对象：在启用遮挡查询的情况下，绘制对象。
3. 检查查询结果：绘制对象后，检查遮挡查询的结果。查询结果将告诉您对象在渲染过程中是否可见。如果查询结果表明对象是可见的（通常表示通过深度测试的像素数量大于零），则继续绘制对象。

初看起来，这种方法似乎有些愚蠢，因为您必须绘制对象才能确定其是否可见。然而，实际上，遮挡查询可以节省GPU大量的处理工作。想象一下，如果您有一个由数千个三角形组成的复杂对象。如果您想使用遮挡查询来确定它的可见性，您只需要绘制该对象的简化表示，例如其包围盒或较低多边形的版本。如果遮挡查询返回简化表示可见（即通过深度测试的样本数量大于零），则意味着复杂对象本身很可能是可见的。因此，您可以避免绘制高多边形数的详细对象，从而节省GPU处理大量不必要的几何数据的时间。

通过这种方式应用遮挡剔除，您可以优化渲染管线，减少对不可见对象的不必要的几何处理，特别是在包含大量对象或复杂模型的场景中，这对于提高性能非常有益。

遮挡剔除是一种强大的技术，用于提高实时图形渲染效率，在各种应用程序和游戏中被广泛使用，可帮助开发人员更有效地利用GPU资源，并将渲染任务集中在可见对象上，从而实现更快速和流畅的复杂场景渲染。

我必须在这里提及，我故意使用了“most probably visible”（很可能可见）这个表达，因为遮挡查询提供的只是对象是否可见的保守估计，而不是确切结果。这是因为包围盒占据了屏幕上与原始几何形状不同（更大）的区域。因此，我们对于遮挡剔除算法的期望是给出以下结果之一：对象不可见或对象很可能可见。这个概率越大，遮挡剔除的效果就越好。

虽然我们总是希望遮挡剔除算法尽可能有效，但通常我们必须在效果和效率之间做出权衡。在上面的例子中，如果我们希望达到100%的效果，那么我们就必须绘制整个对象，这将破坏遮挡剔除的大部分目标。该文章中介绍的算法更加保守，但能够在更大的数据集上使用遮挡剔除，因此在某些情况下是一个比较合理的折衷方案。

## Motivation


使用硬件加速的遮挡查询是在可见性确定中非常有用的强大工具，但它会对应用程序造成相当可观的负担，需要管理遮挡查询并在结果可用时基于查询结果绘制对象（考虑到遮挡查询的异步性质）。最简单粗暴的遮挡查询使用方式是在必须绘制对象之前执行查询。虽然这似乎是一个可行的想法，但实际上它的性能表现并不好，因为CPU必须等待查询结果可用，并且这还涉及GPU中的空闲周期，从而导致性能不可接受。为了解决这个问题，应用程序必须填充查询执行和根据查询结果绘制对象之间的时间间隔。虽然有一些技术可以实现这一点，但这显然会带来成本，因为实现变得更加复杂。

因此，虽然硬件加速的遮挡查询是一个有效的遮挡剔除工具，但在使用它时需要谨慎权衡效果与复杂性。开发人员需要仔细考虑查询执行和绘制之间的时间间隔，以确保在获取结果时能够高效地填充空闲时间。同时，需要优化算法和实现，以减少性能损耗，确保应用程序在运行时能够以最佳方式利用硬件加速遮挡查询的优势。

前面提到的问题在OpenGL 3中引入的条件渲染（NV_conditional_render扩展）部分得到了解决。然而，这个扩展在查询结果尚未可用时什么都不做，然后我们简单地绘制对象，无论其是否可见。这样可以避免渲染管线的停顿，并且如果该扩展不可用，可以在软件中处理，但它在一定程度上削弱了遮挡剔除的目的。

使用遮挡查询的另一个缺陷是仍然需要CPU干预来决定对象的可见性。在当今硬件中，正确的批处理是渲染器性能最重要的方面之一，这种方法相对效率较低。

该文章介绍的遮挡剔除技术通过提供一个非常简单的实现方式来解决这两个问题，可轻松集成到任何渲染器中，并且几乎不会增加渲染器的负担，完全在GPU上进行对象可见性的决策。

## The algorithm

和许多其他基于GPU的剔除算法一样，基于层级Z映射的遮挡剔除利用了几何着色器的能力，以阻止不可见的图元在最终渲染时发射。着色器仅会发射那些可见的对象的数据，并且使用变换反馈（transform feedback）将这些数据流式传输到缓冲区对象中。

这个算法本质上与现代GPU中实现的层级Z测试类似。在渲染场景中的所有遮挡者后，我们从深度缓冲区构建了一个层级深度图，我们称之为Hi-Z映射。这个纹理映射是一个mip-mapped的屏幕分辨率图像，其中每个mip等级i中的纹素包含在mip等级i-1中对应纹素的所有深度的最大值。这些深度信息可以在渲染遮挡对象的主渲染过程中收集，因为我们需要一个相同分辨率的纹理，所以我们不需要单独的深度通道渲染。这可以通过使用OpenGL帧缓冲对象（framebuffer objects）简单地实现。

在构建Hi-Z映射后，可以通过比较对象包围体的深度值和Hi-Z映射中存储的深度信息来执行遮挡剔除。这时候，Hi-Z映射的层级mip-mapped结构非常有用，因为我们可以通过直接从特定mip等级中采样来进行保守深度比较，从而减少纹理取样的次数。

这也是为什么我们使用“存储最大深度”策略来构建Hi-Z映射。这适用于通常的深度缓冲设置，其中深度比较函数为GREATER或GEQUAL。对于反向定向的深度缓冲，必须使用“存储最小深度”策略

### Hi-Z map construction

在单样本渲染的情况下，可以将Hi-Z映射用作渲染场景的主要深度缓冲区。这个技术也适用于多样本渲染，但在这种情况下，需要一个额外的全屏四边形渲染过程，来计算多样本深度缓冲区中每个单独样本的最大深度，并将其存储在单样本的Hi-Z映射中。这是可能的，因为从OpenGL 3.2或使用ARB_texture_multisample扩展开始，OpenGL允许这样做。除了这个额外的步骤，算法本身保持不变。

Hi-Z映射可以使用OpenGL帧缓冲对象（framebuffer objects）构建，通过为每个mip等级渲染一个全屏四边形渲染过程，其中将上一个mip等级绑定为输入纹理，当前mip等级绑定为渲染目标。由于OpenGL允许从同一个纹理对象读取和写入，只要我们不同时访问相同mip等级进行读取和写入操作，算法看起来非常简单，如下所示：（以下是OpenGL的着色器代码）


非常重要的一步是确保视口大小始终至少为1×1，特别是在使用非二次幂（NPOT）纹理时，由于舍入问题可能导致视口大小为0×0。我曾经忘记了这一步，所以我花了一个小时去找原因，为什么我的最后一个mip等级没有填充。

虽然有人可能会怀疑在进行了这么多全屏四边形渲染过程后，这个技术如何能高效，但事实上它非常高效，在我的Radeon HD5770上构建Hi-Z映射不到0.2毫秒。我使用了OpenGL定时器查询（参见ARB_timer_query扩展），所以测量应该相当准确。

用于构建Hi-Z映射的片段着色器非常直观，除了一个细节。由于窗口的宽高比，我们使用了非二次幂深度纹理（NPOT深度纹理），而NPOT纹理使用“floor”约定来确定后续mip等级的尺寸（参见ARB_texture_non_power_of_two扩展）。因此，我们需要进行条件取样，以确保在从奇数尺寸的mip等级进行降采样时，不会忽略边缘纹素。

```c

#version 400 core
 
uniform sampler2D LastMip;
uniform ivec2 LastMipSize;
 
in vec2 TexCoord;
 
void main(void) {
    vec4 texels;
    texels.x = texture(LastMip, TexCoord).x;
    texels.y = textureOffset(LastMip, TexCoord, ivec2(-1, 0)).x;
    texels.z = textureOffset(LastMip, TexCoord, ivec2(-1,-1)).x;
    texels.w = textureOffset(LastMip, TexCoord, ivec2( 0,-1)).x;
 
    float maxZ = max(max(texels.x, texels.y), max(texels.z, texels.w));
 
    vec3 extra;
    // if we are reducing an odd-width texture then fetch the edge texels
    if (((LastMipSize.x & 1) != 0) && (int(gl_FragCoord.x) == LastMipSize.x-3)) {
        // if both edges are odd, fetch the top-left corner texel
        if (((LastMipSize.y & 1) != 0) && (int(gl_FragCoord.y) == LastMipSize.y-3)) {
            extra.z = textureOffset(LastMip, TexCoord, ivec2(1, 1)).x;
            maxZ = max(maxZ, extra.z);
        }
        extra.x = textureOffset(LastMip, TexCoord, ivec2(1,  0)).x;
        extra.y = textureOffset(LastMip, TexCoord, ivec2(1, -1)).x;
        maxZ = max(maxZ, max(extra.x, extra.y));
    } else
    // if we are reducing an odd-height texture then fetch the edge texels
    if (((LastMipSize.y & 1) != 0) && (int(gl_FragCoord.y) == LastMipSize.y-3)) {
        extra.x = textureOffset(LastMip, TexCoord, ivec2( 0, 1)).x;
        extra.y = textureOffset(LastMip, TexCoord, ivec2(-1, 1)).x;
        maxZ = max(maxZ, max(extra.x, extra.y));
    }
    gl_FragDepth = maxZ;
}
```

我曾尝试使用纹理聚合查询（texture gather lookups）来减少每个片段的纹理取样次数，从每个片段4到7次降低到1到3次（参见ARB_texture_gather扩展）。然而，似乎纹理聚合查询只在图像线性采样时有效，为了避免在渲染过程中切换滤波状态所带来的额外负担，我仍然采用简单的纹理查询。因为使用纹理聚合查询并没有对构建Hi-Z映射的时间产生任何显著的影响。


为了调试和演示目的，"Mountains"演示程序内置了一个函数，可以显示Hi-Z映射的不同mip等级的内容。当启用基于Hi-Z映射的遮挡剔除时，按下F2键即可使用此功能。可以使用"+"和"-"键在不同的mip等级之间进行切换。

为了更好地可视化深度缓冲区中的深度信息，我将深度纹理中存储的非线性深度值转换为线性深度值，就像[GeeXLab]中的文章"How to Visualize the Depth Buffer in GLSL"所示。

### Culling with the Hi-Z map